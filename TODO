https://bevyengine.org/examples/math/custom-primitives/
and others nearby

--- plan ---
my 3d camera and lighting is now officially C- level. i can move onto the next mechanic. do i want to give up on the idea of manually driving a ship? i think in either case i need the idea of acceleration and a difference between what way you want the ship to be going and what way the ship is currently going in the moment. in other words, there will be a delay as the ship follows your orders. manual piloting, even though i have a simple version of it now, will i think be a stretch goal to give players another way of playing. the "default" way to play will be to issue orders like a captain. players can equip modules to allow their ships to be manually-piloted. with that in mind the immediate plan is:
- add acceleration to current controls. the ship will have a max acceleration and a max velocity.
- add two orbit distances the player can toggle between with 1 and 2 keys.

--- references ---
https://bevy.org/examples/2d-rendering/mesh2d-alpha-mode/
^ seems like this might be an easier way to do what i want
working on rendering a target: use https://bevy.org/examples/shaders/shader-material-2d/
i'm not satisfied with the movement abstraction; i want approach, orbit and targeting.
a good first step would be to introduce the idea of acceleration, velocity, facing, and turn time (rotational velocity)
how is targeting going to work? it seems like we could use entity names to fetch the target of a unit.
look at custom primitives link above to see how to make a targeting square like what i want

example for FixedUpdate:
i think some of my systems now with the custom timers could instead use fixedupdate? do some research as to which is better
```
// 1. Define custom components for Velocity and Acceleration
// These are simple wrappers around Vec3, marked with #[derive(Component)]
// Debug is useful for inspecting values during development.
#[derive(Component, Debug)]
pub struct Velocity(pub Vec3);

#[derive(Component, Debug)]
pub struct Acceleration(pub Vec3);

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, setup)
        // Add physics-related systems to the FixedUpdate schedule.
        // Chaining them ensures they run in order: acceleration first, then velocity.
        .add_systems(FixedUpdate, (apply_acceleration, apply_velocity).chain())
        // Configure the FixedUpdate schedule to run at a consistent rate (e.g., 60 times per second)
        .insert_resource(Time::<Fixed>::from_seconds(1.0 / 60.0))
        .run();
}
```

--- ideas for iterative projects ---
tag(done): there's a bot that wants to tag you, then just runs left once it's no longer it
star control: an enemy bot is trying to destroy you. you each shoot bullets. one hit kills. may orbit, approach, or flee

--- units ---
the units of the world are meters. if things are not the right scale for that to be reasonable, i messed up

--- goodies ---
#[cfg(not(target_arch = "wasm32"))]
^ can make native and webasm versions work at once

--- notes on getting files out of the steam flatpak's blender ---
my "home" dir is ~/.var/app/com.valvesoftware.Steam

--- notes on making models in bevy that render the right way in this project ---
i haven't found the right way yet, but i will denote here once i know how

how to configure models in blender:
model facing x+
top facing z+
+Y up unchecked
